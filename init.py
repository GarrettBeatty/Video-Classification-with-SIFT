import cv2
from sklearn.model_selection import train_test_split
import os
import skvideo.io
import numpy as np
from scipy.spatial import KDTree
from sklearn.svm import LinearSVC
from sklearn.metrics import accuracy_score, precision_score, recall_score
from sklearn.utils import shuffle

sift = cv2.xfeatures2d.SIFT_create()


def get_x_y(path, positive_class):
    """
    
    :param path: 
    :param positive_class: 
    :return: 
    """
    x = []
    y = []
    for folder in os.listdir(path):
        if folder == '.DS_Store': # ignore autogenerated file on macs
            continue
        for file in os.listdir(os.path.join(path, folder)):
            if file =='.DS_Store': # ignore autogenerated file on macs
                continue
            x.append(os.path.join(path, folder, file))
            y.append(folder == positive_class)

    return x, y


def compute_sift(image):
    """
    
    :param image: 
    :return: 
    """
    gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    kp, des = sift.detectAndCompute(gray, None)  # keypoints, descriptors
    return des


def calc_bow(list_videos, kdtree, bins, method='mean'):
    """
    
    :param list_videos: 
    :param kdtree: 
    :param bins: 
    :param method: 
    :return: 
    """
    print('calculating BoW...')
    list_videos_hist = []
    for i, video in enumerate(list_videos):
        print('video', i + 1, 'out of', len(list_videos))
        video_hist = []
        for j, frame in enumerate(video):
            print('Frame', j + 1, 'out of', len(video))
            dis, indices = kdtree.query(frame)
            hist, _ = np.histogram(indices, bins=bins)
            hist = hist / len(indices) #normalizes

            video_hist.append(hist)

        video_hist = np.array(video_hist)

        if method == 'mean':
            video_hist = np.mean(video_hist, 0)
        elif method == 'max':
            video_hist = np.amax(video_hist, 0)
        elif method == 'mode':
            pass

        list_videos_hist.append(video_hist)

    return np.array(list_videos_hist)


def create_train_test(root_path, save_path, positive_class_name):
    """
    
    :param root_path: 
    :param save_path: 
    :param positive_class_name: 
    :return: 
    """
    movies_path = os.path.join(root_path, 'movies')

    x, y = get_x_y(movies_path, positive_class_name)
    x, y = shuffle(x, y, random_state=42)
    # x, y = x[:5], y[:5]

    features = []

    for i, (video, label) in enumerate(zip(x, y)):

        label = int(label)

        print('video', i + 1, 'out of', len(x))

        videogen = skvideo.io.vreader(video)
        video_frames = []  # all frames for the current video

        for frame in videogen:
            des = compute_sift(frame)
            if des is not None:
                video_frames.append(des)

        features.append(video_frames)

        print()
        print('success', video, 'label:', label)
        print()

    x_train, x_test, y_train, y_test = train_test_split(features, y)
    np.save(os.path.join(save_path, 'xtrain'), x_train)
    np.save(os.path.join(save_path, 'ytrain'), y_train)
    np.save(os.path.join(save_path, 'xtest'), x_test)
    np.save(os.path.join(save_path, 'ytest'), y_test)


def create_dictionary(save_path):
    """
    
    :param save_path: 
    :return: 
    """
    print('Creating dictionary...')
    x_train = np.load(os.path.join(save_path, 'xtrain.npy'))

    dictionary_size = 20
    bow = cv2.BOWKMeansTrainer(dictionary_size)

    # for every training video add every frame to the bow

    for i, video in enumerate(x_train):
        print('video', i + 1, 'out of', len(x_train))
        num_frames = len(video)
        random_perm = np.random.permutation(num_frames)
        for i in random_perm[:5]:
            frame = video[i]
            bow.add(frame)

    dictionary = bow.cluster()  # compute centroids
    np.save(os.path.join(save_path, 'dictionary'), dictionary)
    print('dictionary shape', dictionary.shape)


def create_bow(save_path):
    """
    
    :param save_path: 
    :return: 
    """

    dictionary = np.load(os.path.join(save_path, 'dictionary.npy'))
    x_train = np.load(os.path.join(save_path, 'xtrain.npy'))
    x_test = np.load(os.path.join(save_path, 'xtest.npy'))

    kdtree = KDTree(dictionary)

    x_train_bow = calc_bow(x_train, kdtree, dictionary.shape[0])
    x_test_bow = calc_bow(x_test, kdtree, dictionary.shape[0])

    np.save(os.path.join(save_path, 'xtrainbow'), x_train_bow)
    np.save(os.path.join(save_path, 'xtestbow'), x_test_bow)


def generate_files(root_path, positive_class_name):
    """
    
    :param root_path: 
    :param positive_class_name: 
    :return: 
    """

    save_path = os.path.join(root_path, 'generated')
    os.makedirs(save_path, exist_ok=True)
    create_train_test(root_path, save_path, positive_class_name)
    create_dictionary(save_path)
    create_bow(save_path)
    predict(save_path)


def predict(save_path):
    """
    
    :param save_path: 
    :return: 
    """

    x_train_bow = np.load(os.path.join(save_path, 'xtrainbow.npy'))
    x_test_bow = np.load(os.path.join(save_path, 'xtestbow.npy'))
    y_train = np.load(os.path.join(save_path, 'ytrain.npy'))
    y_test = np.load(os.path.join(save_path, 'ytest.npy'))

    print(x_train_bow.shape)
    print(y_train)
    model = LinearSVC()
    model.fit(x_train_bow, y_train)
    predictions = model.predict(x_test_bow)
    acc = accuracy_score(y_test, predictions)
    precision = precision_score(y_test, predictions)
    recall = recall_score(y_test, predictions)
    print(acc, precision, recall)